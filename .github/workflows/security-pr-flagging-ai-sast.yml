name: Security PR Flagging — AI + Rules-based SAST

# Runs on PR events
on:
  pull_request:
    types: [opened, synchronize, reopened]

permissions:
  contents: read
  pull-requests: write
  checks: write
  statuses: write
  models: read

env:
  # Change to "false" if you only want warnings and do not want to block merges
  BLOCK_ON_WARNINGS: "true"
  # Treat regex "high severity" matches as immediate blockers
  BLOCK_ON_HIGH_SEVERITY_REGEX: "true"
  # GitHub Model to use
  GH_MODEL: "gpt-4o-mini"
  # Temperature 0 for deterministic security results
  MODEL_TEMPERATURE: 0

jobs:
  security-scan:
    runs-on: ubuntu-latest
    name: AI-assisted SAST (rules + GitHub model)
    steps:

      - name: Checkout PR branch
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install small tools (rg, jq, gh)
        run: |
          sudo apt-get update -y
          sudo apt-get install -y ripgrep jq procps
          # Install github CLI if not present
          if ! command -v gh >/dev/null 2>&1; then
            curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg \
              | sudo dd of=/usr/share/keyrings/githubcli-archive-keyring.gpg
            sudo chmod go+r /usr/share/keyrings/githubcli-archive-keyring.gpg
            echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" \
              | sudo tee /etc/apt/sources.list.d/github-cli.list > /dev/null
            sudo apt-get update -y
            sudo apt-get install -y gh
          fi
          gh --version
          rg --version
          jq --version

      - name: Fetch base branch
        run: |
          # Ensure we have the base ref locally
          git fetch origin ${{ github.event.pull_request.base.ref }}:refs/remotes/origin/${{ github.event.pull_request.base.ref }}

      - name: Save PR diff (used by AI)
        run: |
          git diff origin/${{ github.event.pull_request.base.ref }}...HEAD -U0 > pr_diff.txt || true
          echo "=== DIFF START ===" > pr_diff_headline.txt
          head -n 5 pr_diff.txt >> pr_diff_headline.txt || true
          echo "" >> pr_diff_headline.txt
          echo "Changed files:" >> pr_diff_headline.txt
          git diff --name-only origin/${{ github.event.pull_request.base.ref }}...HEAD >> pr_diff_headline.txt

      - name: Get list of changed files
        id: files
        run: |
          git diff --name-only origin/${{ github.event.pull_request.base.ref }}...HEAD > changed_files.txt || true
          wc -l changed_files.txt
          echo "CHANGED_FILES<<EOF" >> $GITHUB_ENV
          cat changed_files.txt >> $GITHUB_ENV
          echo "EOF" >> $GITHUB_ENV

      ####################################################################
      # Rules-based (regex) scanner
      # - quick patterns for common secrets & risky constructs
      # - splits into HIGH and LOW severity rules
      ####################################################################
      - name: Rules-based regex scan (fast)
        id: regexscan
        run: |
          set -uo pipefail

          # Load changed files from env
          printf "%s\n" "$CHANGED_FILES" > /tmp/changed_files_list.txt

          # If there are no changed files, exit gracefully
          if [ ! -s /tmp/changed_files_list.txt ]; then
            echo "::warning::No changed files detected."
            echo "{}" > regex_results.json
            exit 0
          fi

          # HIGH severity patterns (immediate secrets / private keys / tokens)
          # Note: keep patterns conservative to reduce false positives
          HIGH_PATTERNS=(
            # AWS secret access key (rough)
            '[A-Za-z0-9/+=]{40}'
            # AWS access key id (AKIA or ASIA)
            'AKIA[0-9A-Z]{16}|ASIA[0-9A-Z]{16}'
            # Private key begin
            '-----BEGIN (RSA|PRIVATE|EC|OPENSSH) PRIVATE KEY-----'
            # Basic hardcoded password= or password :
            "(password|passwd)[\"']?\s*[:=]\s*['\"].{3,}"
            # Generic long-looking secrets (>=20 chars of base64/hex)
            '([A-Za-z0-9+/]{20,}={0,2})'
          )

          # LOW severity patterns (suspicious but may be false positive)
          LOW_PATTERNS=(
            # eval / exec usage
            '\beval\(|\bexec\('
            # SQL string concatenation (simple)
            '(\"|\')\s*\+\s*\w+\s*\+\s*(\"|\')'
            # Insecure TLS skip (node/requests)
            'rejectUnauthorized\s*[:=]\s*false|verify=False'
            # Hardcoded API keys naming
            'api[_-]?key|secret[_-]?key'
            # TODO: add more as needed
          )

          # Function to test patterns against changed files and aggregate matches
          jq -n '{high:[], low:[]}' > regex_results.json

          while IFS= read -r file; do
            # ignore deleted files and non-text files quickly
            if [ -z "$file" ] || [ ! -f "$file" ]; then
              continue
            fi

            # Only scan typical text/code files
            case "$file" in
              *.png|*.jpg|*.jpeg|*.gif|*.pdf|*.zip|*.bin) continue ;;
            esac

            # Run ripgrep for HIGH_PATTERNS
            for pat in "${HIGH_PATTERNS[@]}"; do
              # --no-messages to avoid binary warnings, -n prints line number
              rg --no-filename -n --pcre2 "$pat" "$file" 2>/dev/null | while IFS=: read -r line content; do
                # Append to JSON array with file, line, match snippet
                jq --arg f "$file" --arg l "$line" --arg m "$(echo "$content" | sed 's/"/\\"/g' | sed 's/^[[:space:]]*//')" \
                   '.high += [{"file":$f,"line":$l,"snippet":$m,"pattern":$pat}]' regex_results.json > /tmp/rr.json && mv /tmp/rr.json regex_results.json
              done
            done

            # LOW patterns
            for pat in "${LOW_PATTERNS[@]}"; do
              rg --no-filename -n --pcre2 "$pat" "$file" 2>/dev/null | while IFS=: read -r line content; do
                jq --arg f "$file" --arg l "$line" --arg m "$(echo "$content" | sed 's/"/\\"/g' | sed 's/^[[:space:]]*//')" \
                   '.low += [{"file":$f,"line":$l,"snippet":$m,"pattern":$pat}]' regex_results.json > /tmp/rr.json && mv /tmp/rr.json regex_results.json
              done
            done

          done < /tmp/changed_files_list.txt

          # Expose results
          cat regex_results.json
          echo "REGEX_RESULTS<<'JSON'" >> $GITHUB_ENV
          cat regex_results.json >> $GITHUB_ENV
          echo "JSON" >> $GITHUB_ENV

      ####################################################################
      # AI analysis: use PR diff to let the model look for logic issues,
      # bypassed auth, insecure patterns across files, contextual concerns.
      ####################################################################
      - name: AI Security Analysis (GitHub model)
        id: ai
        env:
          GH_MODEL: ${{ env.GH_MODEL }}
          MODEL_TEMPERATURE: ${{ env.MODEL_TEMPERATURE }}
        run: |
          set -uo pipefail

          # Read the diff (we saved earlier)
          DIFF_FILE=pr_diff.txt
          if [ ! -s "$DIFF_FILE" ]; then
            echo "::warning::Empty diff; nothing to analyze with AI."
            echo "NO_RISK" > ai_analysis.txt
            echo "AI_ANALYSIS<<'TXT'" >> $GITHUB_ENV
            cat ai_analysis.txt >> $GITHUB_ENV
            echo "TXT" >> $GITHUB_ENV
            exit 0
          fi

          # Compose system prompt - be strict about security, but concise.
          read -r -d '' SYSTEM_PROMPT <<'PROMPT' || true
You are a strict security reviewer specialized in code-level security. Analyze the provided PR diff and:
- Identify any risky security patterns (bypassed authentication/authorization, insecure input validation, SQL injection, command injection, unsafe `eval`/`exec`, insecure deserialization, hardcoded credentials, use of weak crypto/incorrect TLS handling).
- For each finding, emit a JSON list of objects with fields: "severity" (HIGH|MEDIUM|LOW), "summary", "file", "line_hint" (if available), and "explain" (one short sentence).
- If no risky patterns are found, output the single token: NO_RISK
Respond ONLY with valid JSON or the token NO_RISK.
PROMPT

          # Call GitHub Model via gh api GraphQL createChatCompletion (GraphQL mutation)
          # We send a minimal payload with system and user messages; temperature=0
          RESPONSE=$(gh api graphql -f query='
            mutation($input: CreateChatCompletionInput!) {
              createChatCompletion(input: $input) {
                message {
                  content
                }
              }
            }' -F input="$(jq -nc --arg sys "$SYSTEM_PROMPT" --arg diff "$(cat pr_diff.txt)" --arg model "$GH_MODEL" --argjson temp $MODEL_TEMPERATURE '{
              model: $model,
              temperature: $temp,
              messages: [
                {role:"system", content: $sys},
                {role:"user", content: $diff}
              ],
              max_tokens: 1200
            }')" --jq '.data.createChatCompletion.message.content')

          # Save output
          echo "$RESPONSE" > ai_analysis.txt || true
          echo "AI_ANALYSIS<<'TXT'" >> $GITHUB_ENV
          cat ai_analysis.txt >> $GITHUB_ENV
          echo "TXT" >> $GITHUB_ENV

          # Print for logs
          echo "=== AI OUTPUT START ==="
          cat ai_analysis.txt
          echo "=== AI OUTPUT END ==="

      ####################################################################
      # Aggregate results, fail or warn, and leave a PR comment
      ####################################################################
      - name: Aggregate & decide (fail on policy)
        id: decide
        env:
          BLOCK_ON_WARNINGS: ${{ env.BLOCK_ON_WARNINGS }}
          BLOCK_ON_HIGH_SEVERITY_REGEX: ${{ env.BLOCK_ON_HIGH_SEVERITY_REGEX }}
        run: |
          set -uo pipefail

          # Load JSON results
          REGEX_JSON="$REGEX_RESULTS"
          AI_OUT="$AI_ANALYSIS"

          # Build human-friendly summary
          summary_file=security_summary.md
          echo "# Security Analysis Report" > $summary_file
          echo "" >> $summary_file
          echo "Generated by: rules-based scanner + GitHub model" >> $summary_file
          echo "" >> $summary_file

          # Add regex findings
          echo "## Rules-based scanner findings" >> $summary_file
          echo "" >> $summary_file

          if [ "$(echo "$REGEX_JSON" | jq '.high | length')" -gt 0 ]; then
            echo "### HIGH severity (regex)" >> $summary_file
            echo "" >> $summary_file
            echo "$REGEX_JSON" | jq -r '.high[] | "- `\(.file):\(.line)` — \(.pattern) — snippet: ``\(.snippet|gsub("\n";" "))``"' >> $summary_file
            echo "" >> $summary_file
          else
            echo "- No HIGH severity regex matches found." >> $summary_file
            echo "" >> $summary_file
          fi

          if [ "$(echo "$REGEX_JSON" | jq '.low | length')" -gt 0 ]; then
            echo "### LOW/INFO severity (regex)" >> $summary_file
            echo "" >> $summary_file
            echo "$REGEX_JSON" | jq -r '.low[] | "- `\(.file):\(.line)` — \(.pattern) — snippet: ``\(.snippet|gsub("\n";" "))``"' >> $summary_file
            echo "" >> $summary_file
          else
            echo "- No LOW severity regex matches found." >> $summary_file
            echo "" >> $summary_file
          fi

          # Add AI findings
          echo "## AI model findings" >> $summary_file
          echo "" >> $summary_file
          if echo "$AI_OUT" | grep -q '^NO_RISK$'; then
            echo "- AI model: NO_RISK" >> $summary_file
          else
            # Assume AI returned JSON list
            if echo "$AI_OUT" | jq -e . >/dev/null 2>&1; then
              echo "$AI_OUT" | jq -r '.[] | "- [\(.severity)] \(.summary) (\(.file // "unknown"): \(.line_hint // "-")) — \(.explain)"' >> $summary_file
            else
              # If AI output unexpected, include raw
              echo "#### AI raw output (unexpected format):" >> $summary_file
              echo '```' >> $summary_file
              echo "$AI_OUT" >> $summary_file
              echo '```' >> $summary_file
            fi
          fi

          echo "" >> $summary_file

          # Expose summary to environment for PR comment
          echo "SECURITY_SUMMARY<<'MD'" >> $GITHUB_ENV
          cat $summary_file >> $GITHUB_ENV
          echo "MD" >> $GITHUB_ENV

          # Decide blocking logic
          BLOCK_REASON=""
          # Block if high regex matches exist and configured to block on those
          if [ "$(echo "$REGEX_JSON" | jq '.high | length')" -gt 0 ] && [ "${BLOCK_ON_HIGH_SEVERITY_REGEX}" = "true" ]; then
            BLOCK_REASON="High severity regex findings"
          fi

          # Block if AI returned findings (not NO_RISK) and BLOCK_ON_WARNINGS=true
          if ! echo "$AI_OUT" | grep -q '^NO_RISK$' && [ "${BLOCK_ON_WARNINGS}" = "true" ]; then
            if [ -z "$BLOCK_REASON" ]; then
              BLOCK_REASON="AI-detected security findings"
            else
              BLOCK_REASON="$BLOCK_REASON; AI also reported findings"
            fi
          fi

          if [ -n "$BLOCK_REASON" ]; then
            echo "BLOCK=true" >> $GITHUB_ENV
            echo "BLOCK_REASON=$BLOCK_REASON" >> $GITHUB_ENV
            echo "::error title=Security check blocked::${BLOCK_REASON}"
            # We do not exit here; the final step will fail explicitly so the "comment" step runs with if: always()
          else
            echo "BLOCK=false" >> $GITHUB_ENV
            echo "::notice::No blocking security findings detected."
          fi

      - name: Post comment on PR with results
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            const body = process.env.SECURITY_SUMMARY || "No summary generated.";
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const issue_number = context.issue.number;

            // Post the PR comment
            await github.rest.issues.createComment({
              owner,
              repo,
              issue_number,
              body: `🔐 **Automated Security Report**\n\n${body}\n\n---\n*This check is automated: rules-based scanner + GitHub Model.*`
            });

      # Final step: fail the job if we determined we must block
      - name: Fail job if blocking policy triggered
        if: always()
        run: |
          if [ "${BLOCK:-false}" = "true" ]; then
            echo "Failing job due to: ${BLOCK_REASON}"
            exit 1
          else
            echo "No blocking findings. Job will pass."
          fi
